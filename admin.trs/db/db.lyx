#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ctex-book
\begin_preamble
% 如果没有这一句命令，XeTeX会出错，原因参见
% http://bbs.ctex.org/viewthread.php?tid=60547
\DeclareRobustCommand\nobreakspace{\leavevmode\nobreak\ }
\end_preamble
\options UTF8
\use_default_options true
\maintain_unincluded_children false
\language chinese-simplified
\language_package none
\inputencoding utf8-plain
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
使用数据库
\end_layout

\begin_layout Standard
本节中的主题介绍如何创建和管理数据库对象并操纵数据库中的数据。 也描述了并行数据加载。
\end_layout

\begin_layout Chapter
定义数据库对象 
\end_layout

\begin_layout Standard
数据库中的使用数据定义语言（DDL）创建和管理数据库对象。DEEPGREEN 的数据库，Schema， 等于PostgreSQL并没有不同。但表的DDL与Pos
tgreSQL比较，有更多的选项和功能。我们仅描述创建，管理表。
\end_layout

\begin_layout Section
创建和管理表
\end_layout

\begin_layout Standard
DeepGreen数据库表与任何关系数据库中的表相似，只是表行分布在系统中的Segment。 创建表时，可以指定表的分发策略。CREATE TABLE命令创建一
个表并定义其结构。 创建表时，您可以定义：
\end_layout

\begin_layout Itemize
表的列及其关联的数据类型。
\end_layout

\begin_layout Itemize
用于限制列或表可以包含的数据的任何表或列约束。
\end_layout

\begin_layout Itemize
该表的分发策略决定了数据库如何划分数据。 
\end_layout

\begin_layout Itemize
表的存储方式。
\end_layout

\begin_layout Itemize
大表的分区策略。 
\end_layout

\begin_layout Subsection
选择列数据类型 
\end_layout

\begin_layout Standard
列的数据类型决定列可以包含的数据值的类型。选择使用尽可能少的空间但仍然可以容纳您的数据并最有效地约束数据的数据类型。
\end_layout

\begin_layout Standard
对于包含文本数据的表列，请指定数据类型VARCHAR或TEXT。不建议指定数据类型CHAR。
\end_layout

\begin_layout Standard
使用最小的数字数据类型，例如，使用BIGINT适用于INT或SMALLINT的数据会浪费存储空间。如果数据值值可能会扩大，从较小的数据类型更改为较大的数据类型是
比较昂贵的。这时，较大的数据类型可能是更好的长期选择。
\end_layout

\begin_layout Standard
对于计划在跨表连接中使用的列，请使用相同的数据类型。跨表连接通常使用一个表中的主键和另一个表中的外键。当数据类型不同时，数据库必须转换类型，以便可以正确比较数据
值。 这会增加不必要的开销。
\end_layout

\begin_layout Subsection
设置约束
\end_layout

\begin_layout Standard
您可以在列和表上定义约束以限制表中的数据。 DeepGreen 数据库支持的约束与PostgreSQL相同，但有一些限制，包括：
\end_layout

\begin_layout Itemize
CHECK约束只能指向本表。 
\end_layout

\begin_layout Itemize
UNIQUE和PRIMARY KEY约束必须与其表的分布键和分区键（如果有的话）兼容。
\begin_inset Foot
status open

\begin_layout Plain Layout
AO 表不支持 UNIQUE 和 PRIMARY KEY 约束
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
DDL允许有FOREIGN KEY约束，但并不强制。 
\end_layout

\begin_layout Itemize
分区表上定义的约束会被应用于整个表。 不能定义只在一个单独分区表上的约束。
\end_layout

\begin_layout Subsection
选择分布
\end_layout

\begin_layout Standard
所有的表都是分布式的。 创建或更改表时，可以选择指定DISTRIBUTED BY （hash distribution） 或DISTRIBUTED
 RANDOMLY（round-robin distribution）。 选择分布方式时主要有以下考量。
\end_layout

\begin_layout Itemize
为了获得最佳性能，所有Segment应包含大体相等的数据部分。如果数据不平衡或偏斜，则具有更多数据的Segment就比较慢。最好选择每个记录唯一的分布键，例如主
键。 
\end_layout

\begin_layout Itemize
本地操作比分布式操作快。如果与连接，排序或聚合操作相关联的工作在本地完成，查询处理速度最快。如果系统需要在segment间重新分布数据，就会效率较低。
\end_layout

\begin_layout Itemize
为了获得最佳性能，所有Segment应处理大体相等份额查询工作负载。如果表的数据分发策略和查询不匹配，查询工作负载可能会发生倾斜。
\end_layout

\begin_layout Standard
主键始终是表的分配列。 如果没有主键存在，但唯一键存在，这是表的分配列。
\end_layout

\begin_layout Section
选择表的存储方式
\end_layout

\begin_layout Subsection
堆存储 (Heap)
\end_layout

\begin_layout Standard
默认情况下，DeepGreen 数据库使用与PostgreSQL相同的堆存储模型。 堆表存储最适合使用OLTP类型的工作负载，其中数据在初始加载后经常被修改。
 UPDATE和DELETE操作需要存储行级版本信息，以确保可靠的数据库事务处理。 堆表最适合于较小的表，它们在最初加载之后经常更新。
\end_layout

\begin_layout Subsection
Append Optimized （AO）
\end_layout

\begin_layout Standard
AO表存储最适合数据仓库环境中的事实表。 事实表通常是系统中最大的表。 事实表通常分批加载并以只读查询访问。 大型事实表移动到AO存储模型中消除了每行更新可见性
信息的存储开销，每行约20个字节.
 AO 表的存储模型针对批量数据加载进行了优化。 不建议使用单行INSERT语句。
\end_layout

\begin_layout Subsection
行存和列存
\end_layout

\begin_layout Standard
DeepGreen 提供行存，列存或两者的组合。 
\end_layout

\begin_layout Itemize
行存：适于OLTP类型的工作负载以及单行索引查询。
\end_layout

\begin_layout Itemize
列存：适于对少数列数据聚合等OLAP型工作负载。
\end_layout

\begin_layout Standard
对于大多数通用或混合工作负载，行存提供了灵活性和性能的最佳组合。 但是，有一些时候，列存模型提供更高效的I / O和存储。 在决定表的存储方向时，请考虑以下要求
，
\end_layout

\begin_layout Itemize
更新数据。如果经常更新数据，请选择一个行存堆表。列存只能在AO表上使用。 
\end_layout

\begin_layout Itemize
频繁插入。如果行被频繁地插入到表中，那么考虑一个行存的模型。列存未针对少量，但频繁写操作进行优化。
\end_layout

\begin_layout Itemize
查询中请求的列数。如果您通常要求SELECT列表中的所有，或大部分列，请考虑面向行存。列存的表最适合于在少数几个列上的查询。
\end_layout

\begin_layout Itemize
表中的列数。当同时需要许多列时，或者当表的行大小相对较小时，面向行的存储效率更高。面向列的表可以在具有许多列的表上提供更好的查询性能。 
\end_layout

\begin_layout Itemize
压缩。每列数据具有相同的数据类型，许多压缩方案列存压缩更好。
\end_layout

\begin_layout Subsection
压缩 （只适用于AO表）
\end_layout

\begin_layout Standard
在DeepGreen数据库中AO表可有两种类型的压缩：
\end_layout

\begin_layout Itemize
表级压缩应用于整个表。 
\end_layout

\begin_layout Itemize
列级压缩应用于特定列。 
\end_layout

\begin_layout Standard
DeepGreen 支持 ZLIB， LZ4， ZSTD 压缩算法。相比，LZ4 最快，但压缩比不如ZLIB和ZSTD。 ZSTD 和 ZLIB压缩比类似，但Z
STD要更快。
\end_layout

\begin_layout Subsection
例子
\end_layout

\begin_layout Itemize
面向行的堆表是默认的存储类型。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> CREATE TABLE foo (a int, b text) DISTRIBUTED BY (a);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
使用CREATE TABLE命令的WITH子句声明表存储选项。 例如，创建一个没有压缩的append优化的表
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> CREATE TABLE bar (a int, b text)      
\end_layout

\begin_layout Plain Layout

   WITH (appendonly=true)     
\end_layout

\begin_layout Plain Layout

   DISTRIBUTED BY (a);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
使用面向列的存储的表必须是AO表。 例如，创建一个面向列的表
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> CREATE TABLE bar (a int, b text)      
\end_layout

\begin_layout Plain Layout

   WITH (appendonly=true, orientation=column)     
\end_layout

\begin_layout Plain Layout

   DISTRIBUTED BY (a);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
CREATE TABLE命令的WITH子句声明表存储选项。 使用压缩的表必须是AO表。 例如，创建一个压缩级别为5的zlib压缩的AO表
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> CREATE TABLE foo (a int, b text)     
\end_layout

\begin_layout Plain Layout

   WITH (appendonly=true, compresstype=zlib, 
\end_layout

\begin_layout Plain Layout

         compresslevel=5);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
还可以为列指定压缩方式
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE T1 (
\end_layout

\begin_layout Plain Layout

  c1 int ENCODING (compresstype=zlib),                   
\end_layout

\begin_layout Plain Layout

  c2 char ENCODING (compresstype=lz4),
\end_layout

\begin_layout Plain Layout

  c3 char)
\end_layout

\begin_layout Plain Layout

WITH (appendonly=true, orientation=column);
\end_layout

\end_inset


\end_layout

\begin_layout Section
改变一个表
\end_layout

\begin_layout Standard
ALTER TABLE命令更改表的定义。 使用ALTER TABLE来更改表属性，如列定义，分发策略，存储模型和分区结构。 例如，要为表列添加非空约束：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> ALTER TABLE address ALTER COLUMN street SET NOT NULL;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
更改表分布
\end_layout

\begin_layout Standard
ALTER TABLE提供了更改表的分发策略的选项。当表分配选项更改时，表数据重新分布在磁盘上。您还可以使用现有的分发策略重新分发表数据。 
\end_layout

\begin_layout Subsubsection
更改分配策略
\end_layout

\begin_layout Standard
对于分区表，分发策略的更改递归应用于子分区。此操作将保留表的所有权和所有其他属性。例如，以下命令使用customer_id列作为分发列，重新分配所有Segmen
t 的 SALES 表：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SET DISTRIBUTED BY（customer_id）;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
当您更改表的分布时，表数据将自动重新分发。将分配策略更改为随机分布不会导致重新分配数据。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SET DISTRIBUTED RANDOMLY;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
重新分配表数据
\end_layout

\begin_layout Standard
要为具有随机分配策略的表重新分配表数据使用REORGANIZE = TRUE。例如，以下命令使用当前分发策略（包括随机分布）在所有Segment重新分配表数据。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SET WITH（REORGANIZE = TRUE）;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
更改表存储模型
\end_layout

\begin_layout Standard
表存储，压缩和方向只能在创建时声明。 要更改存储模型，必须创建具有正确存储选项的表，将原始表数据加载到新表中，删除原始表，并使用原始表的名称重命名新表。
 您还必须重新授予任何表权限。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales2 (LIKE sales)  
\end_layout

\begin_layout Plain Layout

WITH (appendonly=true, compresstype=lz4, 
\end_layout

\begin_layout Plain Layout

      orientation=column); 
\end_layout

\begin_layout Plain Layout

INSERT INTO sales2 SELECT * FROM sales; 
\end_layout

\begin_layout Plain Layout

DROP TABLE sales; 
\end_layout

\begin_layout Plain Layout

ALTER TABLE sales2 RENAME TO sales; 
\end_layout

\begin_layout Plain Layout

GRANT ALL PRIVILEGES ON sales TO admin; 
\end_layout

\begin_layout Plain Layout

GRANT SELECT ON sales TO guest;
\end_layout

\end_inset


\end_layout

\begin_layout Section
大表分区
\end_layout

\begin_layout Standard
表分区可以支持非常大的表，例如事实表，通过逻辑上将它们分割成更小，更易于管理的部分。 分区表可以通过允许DeepGreen查询优化器仅扫描满足给定查询所需的数据
，而不是扫描大表的所有内容，从而提高查询性能。
\end_layout

\begin_layout Subsection
简介
\end_layout

\begin_layout Standard
分区不会改变数据在Segment上的分布。 无论是否分区，DeepGreen都将表分布到所有的Segment上以启用并行查询处理。 表分区逻辑上划分大表，以提高
查询性能，并帮助数据仓库维护任务，例如将旧数据从数据仓库中滚出。
\end_layout

\begin_layout Standard
DeepGreen支持：
\end_layout

\begin_layout Itemize
范围划分：根据数值范围（如日期或价格）划分数据。 
\end_layout

\begin_layout Itemize
列表分区：根据值列表划分数据，如销售地区或产品线。 
\end_layout

\begin_layout Itemize
两种类型的组合。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
分布与分区
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/ftian/work/manual/admin/pic/partitions.jpg
	width 80col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
DeepGreen DDL使用PARTITION BY（和可选的SUBPARTITION BY）子句在CREATE TABLE期间对表进行分区。分区创建一个或多
个级别的子表（或子表）的顶级（或父级）表。在内部，DeepGreen 数据库创建了顶层表与其底层分区之间的继承关系.分区标准来创建具有不同CHECK约束的分区，限
制表可以包含的数据。查询优化器使用CHECK约束来确定要扫描的表分区。
\end_layout

\begin_layout Subsection
决定表分区策略 
\end_layout

\begin_layout Standard
不是所有的表都是分区的好选择。 如果对所有或大多数以下问题的答案是肯定的，表分区是一种可行的数据库设计策略，用于提高查询性能。 如果答案不是以下大部分问题，表分
区不是该表的正确解决方案。
\end_layout

\begin_layout Itemize
表足够大吗？大事实表是表分区的好选择。如果表中有数百万或数十亿条记录，您可能会从逻辑上将数据分解成更小的块，从而获得性能优势。对于只有几千行或更少行的较小的表，
维护分区的管理开销将超过您可能会看到的任何性能优势。 
\end_layout

\begin_layout Itemize
查询性能低吗？与任何性能调优计划一样，仅当针对该表的查询产生比所需的响应时间更慢时，才应对表进行分区。 
\end_layout

\begin_layout Itemize
您的查询有可识别的条件吗？WHERE子句的条件可用于决定访问的分区。例如，如果大多数查询倾向于按日期查找记录，则每月或每周的日期分区设计可能是有益的。或者如果您
倾向于按地区访问记录，请考虑列表分区设计以按地区划分表。 
\end_layout

\begin_layout Itemize
您的数据仓库是否保留了历史数据窗口？分区设计的另一个考虑因素是维护历史数据的业务需求。例如，您的数据仓库可能要求您保留过去十二个月的数据。如果数据按月分区，您可
以轻松地从仓库中删除最早的每月分区，并将当前数据加载到最新的每月分区中。 
\end_layout

\begin_layout Itemize
可以根据一些定义的标准将数据分成几个相等的部分？选择将尽可能均匀地划分数据的分区条件。如果分区包含相对数量的记录，查询性能会根据创建的分区数量进行改进。例如，通
过将大表分成10个分区，查询将比未分区表快10倍，前提是分区被设计为支持查询的标准。
\end_layout

\begin_layout Standard
不要创建比需要更多的分区。 创建太多分区可能会降低管理和维护作业效率，例如VACUUM，恢复Segment，扩展集群，检查磁盘使用情况等。
\end_layout

\begin_layout Standard
除非查询优化器可以根据查询消除分区，分区不会提高查询性能。 扫描每个分区的运行速度比未分区表的速度要慢，因此如果只有少量查询实现分区消除，则避免分区。
 
\end_layout

\begin_layout Standard
由于分区文件的数量可以非常快地增长，因此要对多级分区进行非常小心的处理。 例如，如果一个表被天和城市划分，并且有1000天的数据和1000个城市，则分区总数是一
百万。 面向列的表将每列存储在物理表中，因此如果此表具有100列，则系统将需要为该表管理1亿个文件。
\end_layout

\begin_layout Standard
在确定多级分区策略之前，请考虑使用位图索引的单级分区。 但索引会减缓数据加载，因此建议您使用数据和模式进行性能测试以决定最佳策略。
\end_layout

\begin_layout Subsection
创建分区表 
\end_layout

\begin_layout Standard
使用CREATE TABLE创建分区表。 
\end_layout

\begin_layout Itemize
决定分区设计：日期范围，数值范围或值列表。 
\end_layout

\begin_layout Itemize
选择要对表进行分区的列。 
\end_layout

\begin_layout Itemize
决定你想要的分区层数。 例如，您可以按月创建日期范围分区表，然后按销售区域对每月分区进行子分区。
\end_layout

\begin_layout Subsection
定义日期范围表分区 
\end_layout

\begin_layout Standard
日期范围分区表使用单个日期或时间戳列作为分区键列。 如果需要可以使用相同的分区键列来创建子分区，例如，按月分区，然后按日分区。 考虑最细粒度的分区。
 例如，对于按日期分区的表，您可以按日分区，并具有365个每日分区，而不是按年份划分，然后按月分组，然后按日分组。 多级设计可以减少查询优化时间，但单级分区设计
运行速度更快。
\end_layout

\begin_layout Standard
您可以通过给出一个START值，一个END值和一个定义分区增量值的EVERY子句自动生成分区。 默认情况下，START值总是包含，END值总是排他的。
 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales (id int, date date, amt decimal(10,2)) 
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (date) 
\end_layout

\begin_layout Plain Layout

( START (date '2016-01-01') INCLUSIVE    
\end_layout

\begin_layout Plain Layout

  END (date '2017-01-01') EXCLUSIVE    
\end_layout

\begin_layout Plain Layout

  EVERY (INTERVAL '1 day') );
\end_layout

\end_inset


\end_layout

\begin_layout Standard
您也可以单独声明和命名每个分区。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales (id int, date date, amt decimal(10,2)) 
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (date) 
\end_layout

\begin_layout Plain Layout

( PARTITION Jan16 START (date '2016-01-01') INCLUSIVE ,    
\end_layout

\begin_layout Plain Layout

  PARTITION Feb16 START (date '2016-02-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Mar16 START (date '2016-03-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Apr16 START (date '2016-04-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION May16 START (date '2016-05-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Jun16 START (date '2016-06-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Jul16 START (date '2016-07-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Aug16 START (date '2016-08-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Sep16 START (date '2016-09-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Oct16 START (date '2016-10-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Nov16 START (date '2016-11-01') INCLUSIVE ,   
\end_layout

\begin_layout Plain Layout

  PARTITION Dec16 START (date '2016-12-01') INCLUSIVE                  
  
\end_layout

\begin_layout Plain Layout

  END (date '2017-01-01') EXCLUSIVE );
\end_layout

\end_inset


\end_layout

\begin_layout Standard
您不必为每个分区声明一个END值，只需最后一个分区声明END值。 在这个例子中，Jan16分区在Feb16开始处结束。 
\end_layout

\begin_layout Subsection
定义数字范围表分区 
\end_layout

\begin_layout Standard
数字范围分区表使用单个数字数据类型列作为分区键列。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE rank (id int, rank int, year int, 
\end_layout

\begin_layout Plain Layout

                   gender  char(1), count int) 
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (year) 
\end_layout

\begin_layout Plain Layout

( START (2006) END (2016) EVERY (1),    
\end_layout

\begin_layout Plain Layout

  DEFAULT PARTITION extra ); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
定义列表表分区 
\end_layout

\begin_layout Standard
可以使用任何定义了相等函数的数据类型作为其分区键进行列表分区。列表分区还可以使用多列（复合）分区键，而范围分区只允许单列作为分区键。 对于列表分区，您必须为要创
建的每个分区（列表值）声明一个分区规范。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE rank (id int, rank int, year int, 
\end_layout

\begin_layout Plain Layout

                   gender  char(1), count int )  
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY LIST (gender) 
\end_layout

\begin_layout Plain Layout

( PARTITION girls VALUES ('F'),    
\end_layout

\begin_layout Plain Layout

  PARTITION boys VALUES ('M'),    
\end_layout

\begin_layout Plain Layout

  DEFAULT PARTITION other );
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
定义多级分区 
\end_layout

\begin_layout Standard
可以创建具有子分区的多级分区设计。 使用子分区模板可确保每个分区具有相同的子分区设计，包括稍后添加的分区。 例如，以下SQL创建两级分区设计：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales (trans_id int, date date, 
\end_layout

\begin_layout Plain Layout

amount  decimal(9,2), region text)  
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (trans_id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (date) 
\end_layout

\begin_layout Plain Layout

SUBPARTITION BY LIST (region) 
\end_layout

\begin_layout Plain Layout

SUBPARTITION TEMPLATE 
\end_layout

\begin_layout Plain Layout

( SUBPARTITION usa VALUES ('usa'),    
\end_layout

\begin_layout Plain Layout

  SUBPARTITION asia VALUES ('asia'),    
\end_layout

\begin_layout Plain Layout

  SUBPARTITION europe VALUES ('europe'),    
\end_layout

\begin_layout Plain Layout

  DEFAULT SUBPARTITION other_regions)   
\end_layout

\begin_layout Plain Layout

  (START (date '2011-01-01') INCLUSIVE    
\end_layout

\begin_layout Plain Layout

   END (date '2012-01-01') EXCLUSIVE    
\end_layout

\begin_layout Plain Layout

   EVERY (INTERVAL '1 month'),     
\end_layout

\begin_layout Plain Layout

   DEFAULT PARTITION outlying_dates ); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
以下示例显示了三级分区设计，其中销售表按年份，然后按月份，然后区域进行分区。 SUBPARTITION TEMPLATE子句确保每个年份的分区具有相同的子分区结
构。 该示例在层次结构的每个级别声明一个DEFAULT分区。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE p3_sales (id int, 
\end_layout

\begin_layout Plain Layout

       year int, month int, day int,  
\end_layout

\begin_layout Plain Layout

       region text) 
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id) 
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (year)     
\end_layout

\begin_layout Plain Layout

  SUBPARTITION BY RANGE (month)        
\end_layout

\begin_layout Plain Layout

    SUBPARTITION TEMPLATE (         
\end_layout

\begin_layout Plain Layout

      START (1) END (13) EVERY (1),          
\end_layout

\begin_layout Plain Layout

      DEFAULT SUBPARTITION other_months )            
\end_layout

\begin_layout Plain Layout

        SUBPARTITION BY LIST (region)              
\end_layout

\begin_layout Plain Layout

        SUBPARTITION TEMPLATE (                
\end_layout

\begin_layout Plain Layout

         SUBPARTITION usa VALUES ('usa'),                
\end_layout

\begin_layout Plain Layout

         SUBPARTITION europe VALUES ('europe'),                
\end_layout

\begin_layout Plain Layout

         SUBPARTITION asia VALUES ('asia'),                
\end_layout

\begin_layout Plain Layout

         DEFAULT SUBPARTITION other_regions ) 
\end_layout

\begin_layout Plain Layout

( START (2002) END (2012) EVERY (1),    
\end_layout

\begin_layout Plain Layout

  DEFAULT PARTITION outlying_years );
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
对已建的表分区
\end_layout

\begin_layout Standard
表只能在创建时进行分区。 如果您有要分区的表，则必须创建分区表，将原始表中的数据加载到新表中，删除原始表，并使用原始表的名称重新命名分区表。 您还必须重新授予任
何表权限。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales2 (LIKE sales)  
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (date) 
\end_layout

\begin_layout Plain Layout

( START (date 2016-01-01') INCLUSIVE    
\end_layout

\begin_layout Plain Layout

  END (date '2017-01-01') EXCLUSIVE    
\end_layout

\begin_layout Plain Layout

  EVERY (INTERVAL '1 month') ); 
\end_layout

\begin_layout Plain Layout

INSERT INTO sales2 SELECT * FROM sales; 
\end_layout

\begin_layout Plain Layout

DROP TABLE sales; 
\end_layout

\begin_layout Plain Layout

ALTER TABLE sales2 RENAME TO sales; 
\end_layout

\begin_layout Plain Layout

GRANT ALL PRIVILEGES ON sales TO admin; 
\end_layout

\begin_layout Plain Layout

GRANT SELECT ON sales TO guest;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
分区表的限制
\end_layout

\begin_layout Standard
对于每个分区级别，分区表最多可以有32,767个分区。
\end_layout

\begin_layout Standard
分区表上的主键或唯一约束必须包含所有分区列。唯一索引可以省略分区列;但是，它仅在分区表的部分上执行，而不是整个表上生效。
\end_layout

\begin_layout Standard
如果使用SUBPARTITION子句创建了分区表，或者分区具有子分区，则不支持Leaf 分区和外部表置换。当表的Leaf 分区是外部表时，有如下限制：
\end_layout

\begin_layout Itemize
对于包含外部表分区的分区表的查询只能使用PostgreSQL优化器。 
\end_layout

\begin_layout Itemize
外部表分区是只读外部表。 尝试访问或修改外部表分区中的数据的命令返回错误。
\end_layout

\begin_layout Itemize
如果外部表分区上没有数据更改，则支持以下操作。 否则返回错误。 
\end_layout

\begin_deeper
\begin_layout Itemize
添加或删除列。 
\end_layout

\begin_layout Itemize
更改列的数据类型。
\end_layout

\end_deeper
\begin_layout Itemize
如果分区表包含外部表分区，则不支持这些ALTER PARTITION操作
\end_layout

\begin_deeper
\begin_layout Itemize
设置子分区模板。 
\end_layout

\begin_layout Itemize
更改分区属性。 
\end_layout

\begin_layout Itemize
创建一个默认分区。 
\end_layout

\begin_layout Itemize
设定分布策略。 
\end_layout

\begin_layout Itemize
设置或删除列的NOT NULL约束。 
\end_layout

\begin_layout Itemize
添加或删除约束。 拆分外部分区。
\end_layout

\end_deeper
\begin_layout Itemize
如果Leaf子分区是可读取的外部表，gpcrondump不会从分区表的叶子分区中备份数据。
\end_layout

\begin_layout Subsection
分区表数据加载
\end_layout

\begin_layout Standard
创建分区表结构后，顶级父表是空的。数据会进入到底层子表分区。在多级别分区设计中，只有层次结构底部的子分区包含数据。
\end_layout

\begin_layout Standard
无法映射到子表分区的行将被拒绝，并且加载失败。为了避免在加载时拒绝未映射的行，请使用DEFAULT分区定义分区层次结构。任何与分区的CHECK约束不匹配的行会被
加载到DEFAULT分区中。
\end_layout

\begin_layout Standard
在运行时，查询优化器会扫描整个表的继承层次结构，并使用CHECK表约束来确定要扫描的哪个子表分区以满足查询的条件。 DEFAULT分区（如果您的层次结构有）总是
被扫描。包含数据的DEFAULT分区会减慢整个扫描时间。
\end_layout

\begin_layout Standard
当您使用COPY或INSERT将数据加载到父表中时，数据将自动重新映射到正确的分区。
\end_layout

\begin_layout Standard
将数据加载到分区表中的最佳做法是创建一个中间表，加载，然后将其交换到分区表中。
\end_layout

\begin_layout Subsection
验证分区策略
\end_layout

\begin_layout Standard
查询对分区表时，可以使用EXPLAIN来验证查询优化器仅扫描相关分区的数据。例如，假设销售表是按月分隔的日期范围，并按区域划分，对于以下查询：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

EXPLAIN SELECT * FROM sales 
\end_layout

\begin_layout Plain Layout

WHERE date='01-07-12' AND  region='usa';
\end_layout

\end_inset

此查询的查询计划应仅显示以下表格的表扫描：
\end_layout

\begin_layout Itemize
默认分区返回0-1行（如果您的分区设计有一个） 
\end_layout

\begin_layout Itemize
2012年1月分区（sales_1_prt_1）返回0-1行 
\end_layout

\begin_layout Itemize
美国地区分部（sales_1_2_prt_usa）返回一些行数。 
\end_layout

\begin_layout Standard
以下示例显示查询计划的相关部分。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

->  Seq Scan onsales_1_prt_1 sales 
\end_layout

\begin_layout Plain Layout

               (cost=0.00..0.00 rows=0 width=0) 
\end_layout

\begin_layout Plain Layout

Filter: "date"=01-07-12::date AND region='USA'::text 
\end_layout

\begin_layout Plain Layout

->  Seq Scan onsales_1_2_prt_usa sales 
\end_layout

\begin_layout Plain Layout

               (cost=0.00..9.87 rows=20 width=40)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
确认查询优化器不扫描不必要的分区或子分区（例如，扫描未查询谓词中的月份或区域），并且顶级表的扫描返回0-1行。
\end_layout

\begin_layout Subsubsection
问题排查
\end_layout

\begin_layout Standard
以下限制可能导致查询计划显示分区层次结构的非选择性扫描。
\end_layout

\begin_layout Itemize
查询优化器只有当查询包含使用不可变运算符的直接和简单的表限制时才可以选择性地扫描分区表，如： =，<，<=，>，> =和<> 
\end_layout

\begin_layout Itemize
选择性扫描识别STABLE和IMMUTABLE功能，但不能识别查询中的VOLATILE函数。 例如，WHERE子句（如date> CURRENT_DATE）会导
致查询优化器选择性地扫描分区表，但TIME> TIMEOFDAY则不行。
\end_layout

\begin_layout Subsection
查看分区设计
\end_layout

\begin_layout Standard
您可以使用pg_partitions视图查找有关分区设计的信息。 例如，查看销售表的分区设计，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT partitionboundary, partitiontablename, 
\end_layout

\begin_layout Plain Layout

       partitionname,  partitionlevel, partitionrank  
\end_layout

\begin_layout Plain Layout

FROM pg_partitions  
\end_layout

\begin_layout Plain Layout

WHERE tablename='sales';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
可用以下表和视图显示有关分区表的信息。
\end_layout

\begin_layout Itemize
pg_partition - 跟踪分区表及其继承关系。 
\end_layout

\begin_layout Itemize
pg_partition_templates - 显示使用子分区模板创建的子分区。 
\end_layout

\begin_layout Itemize
pg_partition_columns - 显示分区设计中使用的分区列。
\end_layout

\begin_layout Subsection
管理分区表
\end_layout

\begin_layout Standard
要维护分区表，请对顶级父表使用ALTER TABLE命令。 最常见的情况是删除旧分区并添加新的分区，以维护范围分区设计中的数据滚动窗口。 您可以将旧的分区转换（
交换）为AO压缩存储格式，以节省空间。 如果您的分区设计中有一个默认分区，则可以通过拆分默认分区来添加分区。
\end_layout

\begin_layout Subsubsection
添加分区
\end_layout

\begin_layout Standard
可以使用ALTER TABLE命令添加分区。 如果原始分区设计包含由子分区模板定义的子分区，则根据该模板对新添加的分区进行子分区。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ADD PARTITION              
\end_layout

\begin_layout Plain Layout

  START (date '2017-02-01') INCLUSIVE              
\end_layout

\begin_layout Plain Layout

  END (date '2017-03-01') EXCLUSIVE;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
如果在创建表时未使用子分区模板，可以添加分区时定义子分区：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ADD PARTITION              
\end_layout

\begin_layout Plain Layout

  START (date '2017-02-01') INCLUSIVE              
\end_layout

\begin_layout Plain Layout

  END (date '2017-03-01') EXCLUSIVE       
\end_layout

\begin_layout Plain Layout

  ( SUBPARTITION usa VALUES ('usa'),          
\end_layout

\begin_layout Plain Layout

    SUBPARTITION asia VALUES ('asia'),          
\end_layout

\begin_layout Plain Layout

    SUBPARTITION europe VALUES ('europe') );
\end_layout

\end_inset


\end_layout

\begin_layout Standard
将子分区添加到现有分区时，可以指定要更改的分区。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ALTER PARTITION FOR (RANK(12))       
\end_layout

\begin_layout Plain Layout

  ADD PARTITION africa VALUES ('africa');
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
重命名分区
\end_layout

\begin_layout Standard
分区表使用以下命名约定。 分区的子表名称受到唯一性要求和长度限制。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<parentname>_<level>_prt_<partition_name>
\end_layout

\end_inset

 例如，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sales_1_prt_jan16
\end_layout

\end_inset

对于自动生成的范围分区，如果没有指定名字，则数据库分配数字：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sales_1_prt_1
\end_layout

\end_inset

要重新命名分区子表，请重命名顶级父表。 所有关联子表分区的表名中的<parentname>都被更改。 例如，以下命令：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales RENAME TO globalsales;
\end_layout

\end_inset

会更改想关的子表名称：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

globalsales_1_prt_1
\end_layout

\end_inset

在使用ALTER TABLE命令更改分区表时，请始终按表的分区名称（jan16）引用表，而不是其表名（sales_1_prt_jan16）。
\end_layout

\begin_layout Subsubsection
添加默认分区
\end_layout

\begin_layout Standard
您可以使用ALTER TABLE命令将默认分区添加到分区设计中。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ADD DEFAULT PARTITION other;
\end_layout

\end_inset

如果您的分区设计是多层次的，则层次结构中的每个级别必须具有默认分区。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ALTER PARTITION 
\end_layout

\begin_layout Plain Layout

   FOR (RANK(1)) ADD DEFAULT  PARTITION other;
\end_layout

\begin_layout Plain Layout

ALTER TABLE sales ALTER PARTITION 
\end_layout

\begin_layout Plain Layout

   FOR (RANK(2)) ADD DEFAULT  PARTITION other;
\end_layout

\begin_layout Plain Layout

ALTER TABLE sales ALTER PARTITION 
\end_layout

\begin_layout Plain Layout

   FOR (RANK(3)) ADD DEFAULT  PARTITION other;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
如果传入数据与分区的CHECK约束不匹配，并且没有默认分区，则数据将被拒绝。 默认分区确保不匹配分区的传入数据插入默认分区。
\end_layout

\begin_layout Subsubsection
删除分区
\end_layout

\begin_layout Standard
您可以使用ALTER TABLE命令从分区设计中删除分区。 当您删除具有子分区的分区时，子分区（及其中的所有数据）也会自动删除。 对于范围分区，通常会将旧数据从
数据仓库中滚出，将较旧的分区从范围中删除。 例如：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales DROP PARTITION FOR (RANK(1)); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Truncate 分区
\end_layout

\begin_layout Standard
您可以使用ALTER TABLE命令截断分区。 当您截断具有子分区的分区时，子分区也将自动截断。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales TRUNCATE PARTITION FOR (RANK(1));
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
交换分区
\end_layout

\begin_layout Standard
您可以使用ALTER TABLE命令交换分区。 更换分区交换一个表以替代现有分区。 您只能在分区层次结构的最底层交换分区（只有可以交换包含数据的分区）。
\end_layout

\begin_layout Standard
分区交换可用于数据加载。 例如，加载一个表并将加载的表交换到分区表中。 您可以使用分区交换来将旧分区的存储类型更改为AO表。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE jan12 (LIKE sales) 
\end_layout

\begin_layout Plain Layout

  WITH (appendonly=true); 
\end_layout

\begin_layout Plain Layout

INSERT INTO jan12 SELECT * FROM sales_1_prt_1 ; 
\end_layout

\begin_layout Plain Layout

ALTER TABLE sales EXCHANGE PARTITION 
\end_layout

\begin_layout Plain Layout

  FOR (DATE '2012-01-01')  
\end_layout

\begin_layout Plain Layout

  WITH TABLE jan12;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
警告：如果指定WITHOUT VALIDATION子句，则必须确保您正在为现有分区交换的表中的数据对分区上的约束有效。 否则，对分区表的查询可能会返回不正确的结
果。
\end_layout

\begin_layout Standard
数据库服务器配置参数gp_enable_exchange_default_partition控制EXCHANGE DEFAULT PARTITION子句的可用性
。 该参数的默认值为off，该子句不可用。 如果在ALTER TABLE命令中指定了此子句，将返回错误。
\end_layout

\begin_layout Subsubsection
分割分区
\end_layout

\begin_layout Standard
分割分区将分区划分为两个分区。 您可以使用ALTER TABLE命令拆分分区。 您只能在分区层次结构的最下层分割分区：只能分割包含数据的分区。
 子句中的分割值将归属后面的分区。 例如，要将每月分区分为两个，第一个分区包含日期为1月1日至15日，第二个分区包含日期为1月16日至31日：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SPLIT PARTITION FOR ('2017-01-01') 
\end_layout

\begin_layout Plain Layout

AT ('2017-01-16') 
\end_layout

\begin_layout Plain Layout

INTO (PARTITION jan171to15, PARTITION jan1716to31);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
如果您的分区设计具有默认分区，则必须拆分默认分区以添加分区。
\end_layout

\begin_layout Standard
使用INTO子句时，将当前默认分区指定为第二个分区名称。 例如，要拆分默认范围分区，把2017年1月添加到新的每月分区：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SPLIT DEFAULT PARTITION  
\end_layout

\begin_layout Plain Layout

START ('2017-01-01') INCLUSIVE  
\end_layout

\begin_layout Plain Layout

END ('2017-02-01') EXCLUSIVE  
\end_layout

\begin_layout Plain Layout

INTO (PARTITION jan17, default partition);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
修改子分区模板
\end_layout

\begin_layout Standard
使用ALTER TABLE SET SUBPARTITION TEMPLATE修改分区表的子分区模板。 在设置新的子分区模板后添加的分区具有新的分区设计模版。
 现有分区不被修改。
\end_layout

\begin_layout Standard
以下示例更改此分区表的子分区模板：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales (trans_id int, date date, 
\end_layout

\begin_layout Plain Layout

           amount decimal(9,2), region text)   
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (trans_id)   
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (date)   
\end_layout

\begin_layout Plain Layout

  SUBPARTITION BY LIST (region)   
\end_layout

\begin_layout Plain Layout

  SUBPARTITION TEMPLATE     
\end_layout

\begin_layout Plain Layout

  ( SUBPARTITION usa VALUES ('usa'),       
\end_layout

\begin_layout Plain Layout

    SUBPARTITION asia VALUES ('asia'),       
\end_layout

\begin_layout Plain Layout

    SUBPARTITION europe VALUES ('europe'),       
\end_layout

\begin_layout Plain Layout

    DEFAULT SUBPARTITION other_regions )   
\end_layout

\begin_layout Plain Layout

  ( START (date '2014-01-01') INCLUSIVE     
\end_layout

\begin_layout Plain Layout

    END (date '2014-04-01') EXCLUSIVE     
\end_layout

\begin_layout Plain Layout

    EVERY (INTERVAL '1 month') );
\end_layout

\end_inset


\end_layout

\begin_layout Standard
修改子分区模板，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SET SUBPARTITION TEMPLATE 
\end_layout

\begin_layout Plain Layout

( SUBPARTITION usa VALUES ('usa'),    
\end_layout

\begin_layout Plain Layout

  SUBPARTITION asia VALUES ('asia'),    
\end_layout

\begin_layout Plain Layout

  SUBPARTITION europe VALUES ('europe'),   
\end_layout

\begin_layout Plain Layout

  SUBPARTITION africa VALUES ('africa'),    
\end_layout

\begin_layout Plain Layout

  DEFAULT SUBPARTITION regions );
\end_layout

\end_inset


\end_layout

\begin_layout Standard
之后添加表销售的日期范围分区时，它包括africa子分区。 例如，以下命令创建 usa, asia, europe, africa以及默认分区：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ADD PARTITION "4"   
\end_layout

\begin_layout Plain Layout

START ('2014-04-01') INCLUSIVE    
\end_layout

\begin_layout Plain Layout

END ('2014-05-01') EXCLUSIVE ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
要删除子分区模板，请使用带有空括号的SET SUBPARTITION TEMPLATE。 例如，要清除销售表子分区模板：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales SET SUBPARTITION TEMPLATE ();
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
与外部表交换分区
\end_layout

\begin_layout Standard
可以使用可读的外部表来交换分区表的分区。 外部表数据可以驻留在主机文件系统，NFS或HDFS上。例如，如果您具有使用每月分区创建的分区表，并且对表的大多数查询只
访问较新的数据，则可以将较旧的较少访问的数据复制到外部表，并使用外部表交换旧的分区。 对于仅访问较新数据的查询，不需要扫描较旧的的分区。
\end_layout

\begin_layout Standard
在这些情况下，不支持使用外部表交换分区： 
\end_layout

\begin_layout Itemize
分区表使用SUBPARTITION子句创建，或者分区具有子分区。 
\end_layout

\begin_layout Itemize
分区表包含一个带有检查约束或NOT NULL约束的列。
\end_layout

\begin_layout Standard
一个简单的例子，用外部表交换此分区表的Leaf分区。 分区表包含2010至2013年的数据。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE sales (id int, year int, qtr int, 
\end_layout

\begin_layout Plain Layout

                    day int, region text)   
\end_layout

\begin_layout Plain Layout

DISTRIBUTED BY (id)    
\end_layout

\begin_layout Plain Layout

PARTITION BY RANGE (year)    
\end_layout

\begin_layout Plain Layout

  ( PARTITION yr START (2010) END (2014) EVERY (1) ) ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
分区表有四个Leaf分区。 每个Leaf子分区包含一年的数据。 Leaf子分区表sales_1_prt_yr_1包含2010年的数据。这些步骤将表sales_1
_prt_yr_1与使用gpfdist协议的外部表进行交换：
\end_layout

\begin_layout Enumerate
确保为数据库系统启用了外部表协议。 本示例使用gpfdist协议。 
\end_layout

\begin_layout Enumerate
创建可写外部表。 CREATE WRITABLE EXTERNAL TABLE命令创建与分区表具有相同列的可写外部表。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE WRITABLE EXTERNAL TABLE 
\end_layout

\begin_layout Plain Layout

my_sales_ext ( LIKE sales_1_prt_yr_1 )   
\end_layout

\begin_layout Plain Layout

 LOCATION ( 'gpfdist://gpdb_test/sales_2010' )   
\end_layout

\begin_layout Plain Layout

 FORMAT 'csv'    
\end_layout

\begin_layout Plain Layout

 DISTRIBUTED BY (id) ;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
创建一个可读的外部表，从上一步中创建的可写外部表的目的地读取数据。 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE EXTERNAL TABLE 
\end_layout

\begin_layout Plain Layout

sales_2010_ext ( LIKE sales_1_prt_yr_1)    
\end_layout

\begin_layout Plain Layout

 LOCATION ( 'gpfdist://gpdb_test/sales_2010' )   
\end_layout

\begin_layout Plain Layout

 FORMAT 'csv' ;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
将数据从Leaf分区复制到可写外部表中。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO my_sales_ext SELECT * 
\end_layout

\begin_layout Plain Layout

FROM sales_1_prt_yr_1 ;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
使用外部表交换现有的分区。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales ALTER PARTITION yr_1     
\end_layout

\begin_layout Plain Layout

 EXCHANGE PARTITION yr_1     
\end_layout

\begin_layout Plain Layout

 WITH TABLE sales_2010_ext 
\end_layout

\begin_layout Plain Layout

 WITHOUT VALIDATION;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
删除从分区表中滚出的表。DROP TABLE sales_2010_ext ;
\end_layout

\begin_layout Standard
您可以重命名Leaf子分区的名称，以指示sales_1_prt_yr_1是外部表。
\end_layout

\begin_layout Standard
此示例命令将分区名更改为yr_1_ext，将Leaf分区表的名称更改为sales_1_prt_yr_1_ext。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ALTER TABLE sales 
\end_layout

\begin_layout Plain Layout

RENAME PARTITION yr_1 TO  yr_1_ext ;
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
数据导入导出
\end_layout

\begin_layout Standard
本节中的主题描述了将数据加载和写入数据库，和如何将数据导出。DeepGreen 支持高性能并行数据加载和卸载，并且对于较少量的数据，单文件，非并行数据导入和导出
。
\end_layout

\begin_layout Standard
DeepGreen 可以读取和写入多种类型的外部数据源，包括文本文件，HDFS等。 
\end_layout

\begin_layout Itemize
COPY SQL命令在主主机上的外部文本文件和数据库表之间传输数据。 
\end_layout

\begin_layout Itemize
外部表允许您使用SQL命令（如SELECT，JOIN或SORT EXTERNAL TABLE DATA）直接并行查询数据外的数据，还可以创建外部表的视图。外部表
通常用于使用诸如CREATE TABLE表AS SELECT * FROM ext_table之类的命令将外部数据加载到常规数据库表中。 
\end_layout

\begin_layout Itemize
gpfdist是并行文件分发程序。它允许DeepGreen数据库段从多个文件系统并行加载外部数据。可以在不同的主机和网络接口上运行gpfdist的多个实例，并且
并行访问它们。 
\end_layout

\begin_layout Standard
选择加载数据的方法取决于源数据的特征 - 其位置，大小，格式以及所需的任何转换。 在最简单的情况下，COPY SQL命令可访问的文本文件将数据加载到表中。这不需
要设置，并为较小数量的数据提供良好的性能。使用COPY命令，复制到或从数据库中复制的数据将在主主机和数据库的单个文件之间传递。这会将数据集的总大小限制为外部文件
所在的文件系统的容量，并将数据传输限制为单个文件写入流。
\end_layout

\begin_layout Standard
大数据集的更有效的数据加载选项利用MPP架构并行加载数据。这些方法允许数据从多个文件系统，多个主机上的多个NIC同时加载，实现非常高的数据传输速率。外部表允许您
从数据库内访问外部文件，就像它们是常规数据库表一样。
\end_layout

\begin_layout Section
使用基于文件的外部表
\end_layout

\begin_layout Standard
外部表可以访问存储在数据库外的数据源中的数据。 就像数据存储在常规数据库表中一样。 数据可以从外部表读取或写入外部表。它可以像SELECT和INSERT这样的S
QL命令中的常规数据库表一起使用，并与其他表一起使用。 外部表最常用于加载和卸载数据库数据。使用本章以下协议之一访问外部表数据源。 CREATE
 EXTERNAL TABLE语句不能混合协议。
\end_layout

\begin_layout Standard
DeepGreen 支持可读和可写的外部表，
\end_layout

\begin_layout Itemize
可读外部表用于数据加载。 可读外部表支持在数据仓库中常见的基本提取，转换和加载（ETL）任务。 各Segment 可并行读取外部表数据，以优化大负载操作。
 不能修改可读的外部表。
\end_layout

\begin_layout Itemize
可写外部表用于数据卸载。 可写外部表只支持INSERT。
\end_layout

\begin_layout Subsection
file:// 协议
\end_layout

\begin_layout Standard
file：//协议用于指定操作系统文件位置的URI。 URI包括文件的主机名，端口和路径。 每个文件必须驻留在可由DeepGreen超级用户（gpadmin）访
问的主机上。 URI中使用的主机名必须与gp_segment_configuration系统目录表中注册的Segment主机名称相匹配。
\end_layout

\begin_layout Standard
LOCATION子句可以有多个URI，如下例所示：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE EXTERNAL TABLE ext_expenses (    
\end_layout

\begin_layout Plain Layout

  name text, date date, amount float4, 
\end_layout

\begin_layout Plain Layout

  category text, desc1 text )  
\end_layout

\begin_layout Plain Layout

LOCATION ('file://host1:5432/data/expense/*.csv',            
\end_layout

\begin_layout Plain Layout

       'file://host2:5432/data/expense/*.csv',            
\end_layout

\begin_layout Plain Layout

       'file://host3:5432/data/expense/*.csv')  
\end_layout

\begin_layout Plain Layout

FORMAT 'CSV' (HEADER); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LOCATION子句中指定的URI数量决定并行工作以访问外部表的Segment数。 对于每个URI，DeepGreen将指定一个Segment。
 为了在加载数据时获得最大的并行性，将数据分成与Segment相同数量的大小相同的文件。 这确保所有Segment参与负载。外部文件数不能超过Segment数。
 例如，如果集群每个Segment主机有四个Segment，则可以在每个Segment 主机上放置四个外部文件。 基于file：//协议的表只能是可读表。
 系统视图pg_max_external_files显示每个外部表允许多少文件。 该视图仅适用于file：//协议。 
\end_layout

\begin_layout Subsection
gpfdist://协议
\end_layout

\begin_layout Standard
gpfdist：//协议的URI指向正在运行的gpfdist实例。 gpfdist实用程序从文件主机上的目录并行提供外部数据文件，输送到所有的Segment。
 DeepGreen 自带 gpfdist程序， 一般位于Master 和每个 Segment 主机上的$ GPHOME / bin目录中。
\end_layout

\begin_layout Standard
在外部数据文件所在的主机上运行gpfdist。 gpfdist自动解压缩gzip（.gz）和bzip2（.bz2）文件。您可以使用通配符（*）或其他模式匹配来表示要
读取的多个文件。指定的文件路径是启动gpfdist实例时的相对路径。
\end_layout

\begin_layout Standard
所有Primary Segment都并行访问外部文件，但数量受限于gp_external_max_segments参数 。在CREATE EXTERNAL
 TABLE语句中可使用多个gpfdist数据源来扩展扫描性能。
\end_layout

\begin_layout Subsection
gpfdists://协议
\end_layout

\begin_layout Standard
gpfdists：//协议是gpfdist：//协议的安全版本。 要使用它，您可以使用--ssl选项运行gpfdist程序。 当在URI中指定时，gpfdist
s：//协议允许文件服务器和数据库的加密通信和安全标识，以防止诸如窃听和中间人攻击等攻击。gpfdists实现SSL， 具有以下属性和限制： 
\end_layout

\begin_layout Itemize
需要客户证书。
\end_layout

\begin_layout Itemize
不支持多语言证书。 
\end_layout

\begin_layout Itemize
不支持证书吊销列表（CRL）。 
\end_layout

\begin_layout Itemize
TLSv1协议与TLS_RSA_WITH_AES_128_CBC_SHA加密算法一起使用。 
\end_layout

\begin_layout Itemize
SSL参数无法更改。 
\end_layout

\begin_layout Itemize
支持SSL重新协商。 
\end_layout

\begin_layout Itemize
SSL忽略主机不匹配参数设置为false。 
\end_layout

\begin_layout Itemize
gpfdist文件服务器（server.key）和Greenplum数据库（client.key）不支持包含密码短语的私钥。
\end_layout

\begin_layout Standard
使用gpfdists要求以下客户端证书驻留在每个Segment的$ PGDATA / gpfdists目录中。
\end_layout

\begin_layout Itemize
The client certificate file, client.crt 
\end_layout

\begin_layout Itemize
The client private key file, client.key 
\end_layout

\begin_layout Itemize
The trusted certificate authorities, root.crt
\end_layout

\begin_layout Section
使用 gpfdist
\end_layout

\begin_layout Standard
gpfdist协议提供最好的性能，是最容易设置的。 gpfdist确保最佳地使用数据库系统中的所有的Segment进行外部表读取。本主题介绍使用gpfdist与
外部表的设置和管理任务。
\end_layout

\begin_layout Subsection
gpfdist设置和性能
\end_layout

\begin_layout Standard
考虑以下用于优化ETL网络性能的方案。
\end_layout

\begin_layout Itemize
允许网络流量同时使用所有ETL主机网络接口卡（NIC）。 在ETL主机上运行一个gpfdist实例，然后在外部表定义的LOCATION子句中声明每个NIC的主机
名。
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
使用一个gpfdist， 配置多网卡
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/ftian/work/manual/admin/pic/ext_tables_multinic.jpg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
在ETL主机上的多个gpfdist实例之间平等分配外部表数据。 例如，在具有两个NIC的ETL系统上，运行两个gpfdist实例（每个NIC上一个）来优化数据负
载性能，并将外部表数据文件在两个gpfdists之间均匀分配。
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
多个gpfdist实例
\end_layout

\end_inset


\begin_inset Graphics
	filename /Users/ftian/work/manual/admin/pic/ext_tables.jpg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
控制并行度
\end_layout

\begin_layout Standard
gp_external_max_segs服务器配置参数控制可以同时访问单个gpfdist实例的Segment数。 64是默认值。 您可以设置Segment数量使
某些Segment处理外部数据文件，有些Segment执行其他数据库处理。 此参数应在Master 的postgresql.conf文件中设置。
\end_layout

\begin_layout Subsection
启动，停止 gpfdist
\end_layout

\begin_layout Standard
您可以在当前目录位置或您指定的任何目录中启动gpfdist。 默认端口为8080。 gpfdist的工作目录是当前目录，也可以使用 -d 指定目录。要在后台启动
gpfdist，并将输出消息和错误记录到日志文件中：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ gpfdist -d /var/load_files -p 8081 -l   
\backslash

\end_layout

\begin_layout Plain Layout

        /home/gpadmin/log &
\end_layout

\end_inset

可在同一ETL主机上的启动多个gpfdist实例（参见图2），对每个实例使用不同的基本目录和端口。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ gpfdist -d /var/load_files1 -p 8081 -l   
\backslash

\end_layout

\begin_layout Plain Layout

        /home/gpadmin/log1 & 
\end_layout

\begin_layout Plain Layout

$ gpfdist -d /var/load_files2 -p 8082 -l   
\backslash

\end_layout

\begin_layout Plain Layout

        /home/gpadmin/log2 &
\end_layout

\end_inset


\end_layout

\begin_layout Standard
可使用UNIX kill 停止gpfdist
\end_layout

\begin_layout Subsection
gpfdist疑难解答
\end_layout

\begin_layout Standard
Segment在运行时访问gpfdist。 确保Segment主机具有gpfdist的网络访问权限。 gpfdist是一个Web服务器：通过从segment和m
aster的每个主机运行以下命令来测试连接：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ wget http://gpfdist_hostname:port/filename
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CREATE EXTERNAL TABLE定义必须具有正确的主机名，端口和gpfdist的文件名。 指定相对于gpfdist服务文件的目录（gpfdist启动时
指定的目录路径）的文件名和路径。 如果在系统上启动gpfdist，并且IPv6网络被禁用，gpfdist在测试IPv6端口时会警告。
\end_layout

\begin_layout Standard
如果相应的IPv4端口可用，则gpfdist使用该端口，并且可以忽略IPv6端口的警告。 要查看有关gpfdist测试端口的信息，请使用-V选项。
\end_layout

\begin_layout Standard
有关IPv6和IPv4网络的信息，请参阅操作系统文档。
\end_layout

\begin_layout Standard
DeepGreen数据库包括HTTP请求标头中的X-GP-PROTO，以指示请求来自DeepGreen数据库。当使用gpfdist或gfdists协议读取或写入
数据时，gpfdist实用程序会在请求标头中拒绝不包含X-GP-PROTO的HTTP请求。 如果在头部请求中未检测到X-GP-PROTO，则gpfist会在HT
TP响应头的状态行中返回400错误：400无效请求（无gp-proto）
\end_layout

\begin_layout Section
错误处理
\end_layout

\begin_layout Standard
可读外部表最常用于选择要加载的数据。您可以使用CREATE TABLE AS SELECT或INSERT INTO命令查询外部表数据。默认情况下，如果数据包含错
误，则整个命令将失败，并且数据不会加载到目标数据库表中。
\end_layout

\begin_layout Standard
SEGMENT REJECT LIMIT子句允许您隔离外部表数据中的格式错误，并继续加载正确格式化的行。使用SEGMENT REJECT LIMIT设置错误阈值
，将拒绝限制计数指定为ROWS的数量（默认）或总行数（1-100）的PERCENT。 如果错误行的数量达到SEGMENT REJECT LIMIT，则会中止整个
外部表操作，并且不处理任何行。错误行的限制是每Segment，而不是整个操作。如果错误行的数量未达到SEGMENT REJECT LIMIT，它将处理正确格式的
行，丢弃错误行，如选择， 记入日志。
\end_layout

\begin_layout Subsection
定义具有单行错误隔离的外部表
\end_layout

\begin_layout Standard
以下示例在数据库中内部记录错误，并设置错误阈值为10个错误。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=# CREATE EXTERNAL TABLE ext_expenses (
\end_layout

\begin_layout Plain Layout

        name text, date date,  amount float4, 
\end_layout

\begin_layout Plain Layout

        category text, desc1 text )     
\end_layout

\begin_layout Plain Layout

    LOCATION ('gpfdist://etlhost-1:8081/*',               
\end_layout

\begin_layout Plain Layout

              'gpfdist://etlhost-2:8082/*')    
\end_layout

\begin_layout Plain Layout

    FORMAT 'TEXT' (DELIMITER '|')    
\end_layout

\begin_layout Plain Layout

    LOG ERRORS SEGMENT REJECT LIMIT 10 ROWS;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
可使用内置的SQL函数gp_read_error_log（'external_table'）来读取错误日志数据。 此示例命令显示ext_expenses的日志错
误：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT gp_read_error_log('ext_expenses');
\end_layout

\end_inset


\end_layout

\begin_layout Standard
内置SQL函数gp_truncate_error_log（'external_table'）删除错误数据。 此示例删除从以前的外部表示例创建的错误日志数据：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT gp_truncate_error_log('ext_expenses'); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
在表之间移动数据
\end_layout

\begin_layout Standard
您可以使用CREATE TABLE AS或INSERT ...
 SELECT将外部和外部Web表数据加载到另一个（非外部）数据库表中，并且将根据外部或外部Web表定义，加载可以并行进行。
\end_layout

\begin_layout Standard
如果外部表文件或外部Web表数据源出现错误，则会发生以下情况之一，具体取决于所使用的隔离模式：
\end_layout

\begin_layout Itemize
没有错误隔离模式的表：从该表读取的任何操作都将失败。 
\end_layout

\begin_layout Itemize
具有错误隔离模式的表：整个文件除了有问题的行（受配置的REJECT_LIMIT）外， 将被加载。
\end_layout

\begin_layout Section
使用gpload
\end_layout

\begin_layout Standard
gpload程序使用可读取的外部表和gpfdist或gpfdists加载数据。 它处理基于并行文件的外部表设置，并允许用户在单个配置文件中配置其数据格式，外部表
定义和gpfdist或gpfdists设置。
\end_layout

\begin_layout Itemize
确保您的环境设置。 需要的数据库安装完备，例如gpfdist和Python，以及配置对Segment主机的网络访问。
\end_layout

\begin_layout Itemize
创建加载控制文件。 这是一个YAML格式的文件，指定了数据库连接信息，gpfdist配置信息，外部表选项和数据格式等。例如 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--- VERSION: 1.0.0.1 
\end_layout

\begin_layout Plain Layout

DATABASE: ops 
\end_layout

\begin_layout Plain Layout

USER: gpadmin 
\end_layout

\begin_layout Plain Layout

HOST: mdw-1 
\end_layout

\begin_layout Plain Layout

PORT: 5432 
\end_layout

\begin_layout Plain Layout

GPLOAD:    
\end_layout

\begin_layout Plain Layout

  INPUT:     
\end_layout

\begin_layout Plain Layout

    - SOURCE:          
\end_layout

\begin_layout Plain Layout

      LOCAL_HOSTNAME:            
\end_layout

\begin_layout Plain Layout

        - etl1-1            
\end_layout

\begin_layout Plain Layout

        - etl1-2            
\end_layout

\begin_layout Plain Layout

        - etl1-3            
\end_layout

\begin_layout Plain Layout

        - etl1-4          
\end_layout

\begin_layout Plain Layout

      PORT: 8081          
\end_layout

\begin_layout Plain Layout

      FILE:             
\end_layout

\begin_layout Plain Layout

       - /var/load/data/*     
\end_layout

\begin_layout Plain Layout

    - COLUMNS:            
\end_layout

\begin_layout Plain Layout

        - name: text            
\end_layout

\begin_layout Plain Layout

        - amount: float4            
\end_layout

\begin_layout Plain Layout

        - category: text            
\end_layout

\begin_layout Plain Layout

        - desc: text            
\end_layout

\begin_layout Plain Layout

        - date: date     
\end_layout

\begin_layout Plain Layout

    - FORMAT: text     
\end_layout

\begin_layout Plain Layout

    - DELIMITER: '|'     
\end_layout

\begin_layout Plain Layout

    - ERROR_LIMIT: 25     
\end_layout

\begin_layout Plain Layout

    - LOG_ERRORS: true    
\end_layout

\begin_layout Plain Layout

  OUTPUT:     
\end_layout

\begin_layout Plain Layout

    - TABLE: payables.expenses     
\end_layout

\begin_layout Plain Layout

    - MODE: INSERT    
\end_layout

\begin_layout Plain Layout

  PRELOAD:     
\end_layout

\begin_layout Plain Layout

    - REUSE_TABLES: true  
\end_layout

\begin_layout Plain Layout

SQL:    
\end_layout

\begin_layout Plain Layout

    - BEFORE: "INSERT INTO audit 
\end_layout

\begin_layout Plain Layout

               VALUES('start', current_timestamp)"    
\end_layout

\begin_layout Plain Layout

    - AFTER: "INSERT INTO audit 
\end_layout

\begin_layout Plain Layout

               VALUES('end', current_timestamp)"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
运行，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

gpload -f my_load.yml
\end_layout

\end_inset


\end_layout

\begin_layout Section
使用COPY
\end_layout

\begin_layout Standard
COPY FROM将数据从文件或标准输入复制到表中。 COPY是不平行的：在Master上单个进程中加载数据。 仅对非常小的数据文件推荐使用COPY。Maste
r 必须可以访问COPY源文件。 COPY源文件名是相对于主主机位置的。客户端和MASTER 之间的连接从可以STDIN或STDOUT复制数据。
\end_layout

\begin_layout Standard
默认情况下，COPY会在第一个错误时停止操作：如果数据包含错误，则操作失败，不会加载数据。如果在单行错误隔离模式下运行COPY FROM，则会跳过包含格式错误的
行，并加载格式正确的行。单行错误隔离模式仅适用于包含格式错误的输入文件中的行。如果数据包含诸如违反NOT NULL，CHECK或UNIQUE约束的约束错误，则操
作失败并且不加载数据。
\end_layout

\begin_layout Standard
COPY可以指定SEGMENT REJECT LIMIT。错误行计数是针对每个Segment，而不是整个加载操作。
\end_layout

\begin_layout Standard
如果COPY操作没有达到错误限制，将加载所有格式正确的行并丢弃错误行。可使用LOG ERRORS子句在Greenplum数据库内部捕获数据格式化错误。例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=> COPY country FROM '/data/gpdb/country_data'     
\end_layout

\begin_layout Plain Layout

   WITH DELIMITER '|' LOG ERRORS    
\end_layout

\begin_layout Plain Layout

   SEGMENT REJECT LIMIT 10 ROWS;
\end_layout

\end_inset


\end_layout

\begin_layout Section
优化数据加载和查询性能
\end_layout

\begin_layout Standard
使用以下提示来帮助优化数据加载和后续查询性能。
\end_layout

\begin_layout Itemize
在将数据加载到现有表中之前删除索引。 在全表上创建索引比在每一行被加载时逐步更新更快。而且可以临时增加maintenance_work_mem服务器配置参数，以
帮助加快CREATE INDEX命令。建议仅当系统上没有活动用户时，才能删除并重新创建索引。 
\end_layout

\begin_layout Itemize
在将数据加载到新表中时最后创建索引。创建表，加载数据，再创建的索引。 
\end_layout

\begin_layout Itemize
加载数据后运行ANALYZE。如果大量更改了表中的数据，请运行ANALYZE或VACUUM ANALYZE更新查询优化器的表统计信息。当前统计数据确保优化器在查
询规划期间做出最佳决策，并避免由于不准确或不存在的统计信息导致性能下降。 
\end_layout

\begin_layout Itemize
加载错误后运行VACUUM。如果加载操作不在单行错误隔离模式下运行，则操作将在第一个错误时停止。目标表包含在发生错误之前加载的行。您无法访问这些行，但它们占用磁
盘空间。使用VACUUM命令恢复浪费的空间。
\end_layout

\begin_layout Section
数据导出
\end_layout

\begin_layout Standard
可写外部表允许您从其他数据库表中选择行，并将行输出到文件，命名管道，应用程序。本主题介绍如何使用并行导出（可写外部表）和非并行导出（COPY）。
\end_layout

\begin_layout Subsection
定义基于文件的可写外部表
\end_layout

\begin_layout Standard
将数据输出到文件的可写外部表可使用gpfdist或HDFS 界面gphdfs。使用CREATE WRITABLE EXTERNAL TABLE命令来定义外部表，
并指定输出文件的位置和格式。
\end_layout

\begin_layout Itemize
使用gpfdist协议的可写外部表，Segment 将数据发送到gpfdist，gpfdist将数据写入命名文件。 gpfdist必须在Segment可以通过网
络访问的主机上运行。 gpfdist指向输出主机上的文件位置，并将从Segment接收的数据写入文件。要在多个文件之间划分输出数据，请在可写外部表定义中列出多个
gpfdist URI。 
\end_layout

\begin_layout Itemize
可写外部Web表将数据作为数据流发送到应用程序。例如，从数据库导出数据，并将其发送到连接到另一个数据库或ETL工具的应用程序，以将数据加载到其他位置。可写外部W
eb表使用EXECUTE子句来指定Segment上运行的shell命令，脚本或应用程序，并接受输入数据流。
\end_layout

\begin_layout Standard
您可以选择为可写外部表声明一个分发策略。默认情况下，可写外部表使用随机分配策略。如果要导出数据的源表具有散列分布策略，则为可写外部表定义相同的分发列可以通过消除
在互连上移动行的要求来提高卸载性能。如果从特定表中卸载数据，则可以使用LIKE子句从源表复制列定义和分发策略。
\end_layout

\begin_layout Subsection
使用COPY导出数据
\end_layout

\begin_layout Standard
COPY TO可以从Master上单个进程将数据从表格复制文件（或标准输入）。 COPY TO 可输出表的全部内容，也可使用SELECT语句过滤输出。
 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

COPY 
\end_layout

\begin_layout Plain Layout

(SELECT * FROM country WHERE country_name LIKE 'A%')  
\end_layout

\begin_layout Plain Layout

TO '/home/gpadmin/a_list_countries.out';
\end_layout

\end_inset


\end_layout

\begin_layout Section
数据文件格式
\end_layout

\begin_layout Standard
导入导出数据时，必须指定数据文件的格式。 COPY，CREATE EXTERNAL TABLE和gpload have子句允许您指定数据的格式。
 数据可以分隔文本（TEXT）或逗号分隔值（CSV）格式。 外部数据必须格式正确，才能被数据库读取。 
\end_layout

\begin_layout Subsection
行
\end_layout

\begin_layout Standard
DEEPGREEN 输入数据行由LF字符（换行符0x0A），CR（回车符号0x0D）或CR后跟LF（CR + LF，0x0D 0x0A）分隔。
 LF是UNIX或类UNIX操作系统上的标准换行符表示。 Windows或Mac OS X等操作系统使用CR或CR + LF。 
\end_layout

\begin_layout Subsection
列
\end_layout

\begin_layout Standard
默认列或字段分隔符是文本文件的水平TAB字符（0x09）和CSV文件的逗号字符（0x2C）。您可以在定义数据格式时使用COPY，CREATE EXTERNAL
 TABLE或gpload的DELIMITER子句声明单个字符分隔符。 分隔符字符必须出现在任意两个数据值字段之间。不要在行的开头或结尾放置分隔符。
 例如，如果管道字符（|）是您的分隔符：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data value 1|data value 2|data value 3
\end_layout

\end_inset

以下命令显示使用管道字符作为列分隔符：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

=# CREATE EXTERNAL TABLE ext_table 
\end_layout

\begin_layout Plain Layout

          (name text, date date) 
\end_layout

\begin_layout Plain Layout

LOCATION ('gpfdist://<hostname>/filename.txt) 
\end_layout

\begin_layout Plain Layout

FORMAT 'TEXT' (DELIMITER '|');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
NULL
\end_layout

\begin_layout Standard
NULL表示列或字段中的未知数据。 在的数据文件中，您可以指定一个字符串来表示NULL。 TEXT模式下的默认字符串为
\backslash
 N（反斜杠-N），CSV模式中没有引号的空值。 您还可以在定义数据格式时使用COPY，CREATE EXTERNAL TABLE或gpload的NULL子句声
明不同的字符串。 例如，如果不想将空值与空字符串区分开，可以使用空字符串。 当使用加载工具时，与指定的空字符串匹配的任何数据项将被视为空值。
\end_layout

\begin_layout Subsection
转义
\end_layout

\begin_layout Standard
有两个保留字符有特殊的意义：
\end_layout

\begin_layout Itemize
指定的分隔符字符分隔数据文件中的列或字段。 
\end_layout

\begin_layout Itemize
换行符在数据文件中指定一个新行。 
\end_layout

\begin_layout Standard
如果您的数据包含这些字符，您必须转义该字符。 默认情况下，转义字符是文本格式文件的
\backslash
（反斜线）和csv格式文件的双引号（“）。
\end_layout

\begin_layout Subsubsection
TEXT格式
\end_layout

\begin_layout Standard
默认情况下，转义字符是文本格式文件的
\backslash
（反斜杠）。 您可以在COPY，CREATE EXTERNAL TABLE或gpload的ESCAPE子句中声明不同的转义字符。 如果您的转义字符出现在您的数据
中，请使用它来自行转义。
\end_layout

\begin_layout Standard
例如，假设您有一个包含三列的表，并且要加载以下三个字段：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

backslash = 
\backslash
 
\end_layout

\begin_layout Plain Layout

vertical bar = | 
\end_layout

\begin_layout Plain Layout

exclamation point = !
\end_layout

\end_inset


\end_layout

\begin_layout Standard
您指定的分隔符为| （管道字符），您指定的转义字符为
\backslash
（反斜杠）。 数据文件中格式化的行如下所示：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

backslash = 
\backslash

\backslash
 | vertical bar = 
\backslash
| | exclamation point = !
\end_layout

\end_inset


\end_layout

\begin_layout Standard
请注意，作为数据一部分的反斜杠字符将以另一个反斜杠字符进行转义，并且作为数据一部分的管道字符将以反斜杠字符进行转义。
\end_layout

\begin_layout Standard
您可以使用转义字符来转义八进制和十六进制序列。 转载的值在加载到Greenplum数据库时转换为等效字符。 例如，要加载＆符号（＆），请使用转义字符来转义其等效
的十六进制（
\backslash
 0x26）或八进制（
\backslash
 046）表示形式。
\end_layout

\begin_layout Standard
您可以使用COPY，CREATE EXTERNAL TABLE或gpload的ESCAPE子句禁用TEXT格式文件中的转义，如下所示：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ESCAPE 'OFF'
\end_layout

\end_inset

这对于包含许多反斜杠字符（如Web日志数据）的输入数据很有用。
\end_layout

\begin_layout Subsubsection
CSV格式
\end_layout

\begin_layout Standard
默认情况下，转义字符是CSV格式文件的“（双引号）”，如果要使用不同的转义字符，请使用COPY，CREATE EXTERNAL TABLE或gpload的ESC
APE子句来声明不同的转义字符。 您的数据中存在您选择的转义字符，您可以使用它来自行转义。
\end_layout

\begin_layout Standard
例如，假设您有一个包含三列的表，并且要加载以下三个字段：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Free trip to A,B 
\end_layout

\begin_layout Plain Layout

5.89 Special 
\end_layout

\begin_layout Plain Layout

rate "1.79"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
您指定的分隔符是，（逗号），您指定的转义字符是“（双引号）”。数据文件中格式化的行如下所示：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"Free trip to A,B","5.89","Special rate ""1.79"""
\end_layout

\end_inset

使用逗号作为数据的一部分的数据值用双引号括起来。 即使字段值用双引号括起来，作为数据一部分的双引号将以双引号进行转义。
\end_layout

\begin_layout Standard
将整个字段嵌入一组双引号可以保证前导和尾部空格字符的保留：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"Free trip to A,B ","5.89 ","Special rate ""1.79"" "
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
字符编码
\end_layout

\begin_layout Standard
字符编码系统由一个代码组成，每个字符从一个字符集与一些其他的东西对齐，例如数字或八位字节序列，以便于数据传输和存储。 DeepGreen数据库支持各种字符集，包
括单字节字符集，如ISO 8859系列和多字节字符集，如EUC（扩展UNIX代码），UTF-8和Mule内部代码。服务器端字符集在数据库初始化期间定义，UTF-
8是默认值，可以更改。客户端可以透明地使用所有受支持的字符集，但是不支持在服务器中使用一些字符集作为服务器端编码。当将数据加载或插入到数据库中时，DeepGre
en将指定客户端编码的数据透明地转换为服务器编码。将数据发送回客户端时，DeepGreen 将数据从服务器字符编码转换为指定的客户端编码。
\end_layout

\begin_layout Standard
数据文件必须是由DeepGreen数据库识别的字符编码。包含无效或不受支持的编码序列的数据文件在加载时报错。
\end_layout

\begin_layout Subsubsection
更改客户端字符编码
\end_layout

\begin_layout Standard
可以通过设置服务器配置参数client_encoding来更改会话的客户端字符编码
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SET client_encoding TO 'latin1';
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
使用XDrive
\end_layout

\begin_layout Section
简介
\end_layout

\begin_layout Standard
首先，XDrive使DeepGreen集群能够访问存储在数据库外部的数据。 DeepGreen数据库使用外部表格接口传送XDrive。要访问数据，用户需要在XD
rive配置中定义“mount point”。一个常见的情况是将XDrive安装在DeepGreen群集的相同节点中。然后，每个DeepGreen数据库段与在l
ocalhost上运行的XDrive服务进行通信。 XDrive也可以在与DeepGreen群集完全不同的主机中运行。通过将XDrive与DeepGreen集群
分离，我们可以在不同的DeepGreen集群之间共享XDrive服务，从而共享数据。
\end_layout

\begin_layout Standard
要访问外部数据源，必须通过XDrive来安装外部数据存储。 XDrive启动时从配置文件读取 mount point 设置。此时，XDrive支持安装存储在NF
S，HDFS和AWS S3中的外部数据。 DeepGreen数据库使用外部表访问XDrive。支持外部表格的数据格式为CSV和SPQ。我们希望在下一个版本中发布
更多的存储系统和更多数据格式的安装点类型。
\end_layout

\begin_layout Section
配置
\end_layout

\begin_layout Standard
XDrive 使用 toml 配置文件。 下面给出例子和注释。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

# This file should be named 'xdrive.toml' 
\end_layout

\begin_layout Plain Layout

# What follows are configurations for xdrive.
 
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[xdrive]
\end_layout

\begin_layout Plain Layout

    #     
\end_layout

\begin_layout Plain Layout

    # Specify the working directory.
 Xdrive 
\end_layout

\begin_layout Plain Layout

    # will cd into this directory at the target 
\end_layout

\begin_layout Plain Layout

    # machine.
 Logs will be written to ${dir}/log/.
     
\end_layout

\begin_layout Plain Layout

    #     
\end_layout

\begin_layout Plain Layout

    dir = "the-home-dir-on-target-machine"
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    #     
\end_layout

\begin_layout Plain Layout

    # Specify the target machines and the port Xdrive 
\end_layout

\begin_layout Plain Layout

    # will use for communication.
 For each entry, an 
\end_layout

\begin_layout Plain Layout

    # Xdrive instance will be started.
     
\end_layout

\begin_layout Plain Layout

    #     
\end_layout

\begin_layout Plain Layout

    host = [ "host1:port1", "host2:port2", ...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

# Each [[xdrive.mount]] specifies a mount-point.
 
\end_layout

\begin_layout Plain Layout

# There can be multiple [[xdrive.mount]].
 
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

[[xdrive.mount]] 
\end_layout

\begin_layout Plain Layout

    name = "name-of-the-mount-point, e.g.
 mydata" 
\end_layout

\begin_layout Plain Layout

    scheme = "file system, e.g.
 nfs, hdfs or s3" 
\end_layout

\begin_layout Plain Layout

    root = "dir-on-the-file-system, e.g.
 /data/warehouse/" 
\end_layout

\begin_layout Plain Layout

    conf = "any-other-conf-specific-to-the-file-system"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
一个常用的配置是为DeepGreen集群的每个节点在 host 设置一个条。 假设您有一个2节点设置，其中主机是mdw，sdw1-1，sdw1-2，sdw2-1
，sdw2-2，您可将设置主机配置如下：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

host = [ "sdw1-1:50000", "sdw2-1:50000", ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
这种设置可以让用户在外部表DDL中用 localhost：50000 连接 XDrive。
\end_layout

\begin_layout Section
部署
\end_layout

\begin_layout Standard
创建配置文件后，使用xdrctl程序将xdrive部署到所有目标计算机：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdrctl deploy path-to-conf-file
\end_layout

\end_inset


\end_layout

\begin_layout Section
启动和停止
\end_layout

\begin_layout Standard
部署之后， 启动和停止xdrive也可以使用xdrctl：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xdrctl {start|stop} path-to-conf-file
\end_layout

\end_inset


\end_layout

\begin_layout Standard
注意，必须首先部署成功，才能用 xdrctl 启动和停止
\end_layout

\begin_layout Section
mount point
\end_layout

\begin_layout Standard
利用与在UNIX中安装文件系统相同的概念，mount point 是表示XDrive中文件系统目录的符号。 它由4个部分组成：mount point
 名称，所有协议或文件系统类型，目录映射，最后是该mount point特有的其他配置。
\end_layout

\begin_layout Standard
例如，为了使用在hd.example.net的端口9000上运行Hadoop HDFS目录 ／data/warehouse，我们可以指定以下配置：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[[xdrive.mount]] 
\end_layout

\begin_layout Plain Layout

name = "dw" 
\end_layout

\begin_layout Plain Layout

scheme = "hdfs" 
\end_layout

\begin_layout Plain Layout

root = "/data/warehouse" 
\end_layout

\begin_layout Plain Layout

conf = "name_node=hd.example.net, port=9000"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
这样，HDFS中/ data / warehouse下的文件将可以通过XDrive上的符号dw访问。
\end_layout

\begin_layout Subsection
AWS S3 Mount Point
\end_layout

\begin_layout Standard
对于AWS S3，将方案指定为“s3”，并将您的凭据放在 $HOME/.aws/credentials 文件里（在拥有xdrive进程的用户的主目录下）。
\end_layout

\begin_layout Subsection
Hadoop Mount Point
\end_layout

\begin_layout Standard
您必须在conf设置中指定name_node和端口号。 例如：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

conf = "name_node=192.168.1.100, port=50070"
\end_layout

\end_inset


\end_layout

\begin_layout Section
使用外部表读XDrive
\end_layout

\begin_layout Standard
您可以通过Deepgreen DB中提供的外部表格机制访问XDrive上的数据。 语法与其它外部表格基本相同。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE EXTERNAL TABLE table_name (columnspec) 
\end_layout

\begin_layout Plain Layout

LOCATION (’xdrive://host:port/mount-point/reader-path’) 
\end_layout

\begin_layout Plain Layout

FORMAT ’CSV’ [csv options]      
\end_layout

\begin_layout Plain Layout

       | ’SPQ’;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
XDrive目前支持两种格式：CSV和SPQ。 SPQ 是DeepGreen专有的高性能列存储格式。使用plugin系统后，我们支持在HDFS上的Parquet
， ORC文件。
\end_layout

\begin_layout Standard
reader-path指定可以使用的UNIX文件路径匹配模式。 如果我们按时间分区了我们的lineitem spq表，并将表片段存储在路径下：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/data/warehouse/lineitem/YYYY/MM/lineitem_part.spq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
那么可以用如下语法读取所有的数据，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LOCATION ('xdrive://host:port/dw/lineitem/*/*/lineitem*.spq')
\end_layout

\end_inset


\end_layout

\begin_layout Section
使用外部表写XDrive
\end_layout

\begin_layout Standard
可写外部表结构写入XDrive的DDL语法稍微复杂一点，
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE WRITABLE EXTERNAL TABLE 
\end_layout

\begin_layout Plain Layout

    write_table_name (columnspec) 
\end_layout

\begin_layout Plain Layout

LOCATION 
\end_layout

\begin_layout Plain Layout

    (’xdrive://host:port/mount-point/writer-path’) 
\end_layout

\begin_layout Plain Layout

FORMAT ’CSV’ [csv options]      
\end_layout

\begin_layout Plain Layout

       | ’SPQ’;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
与阅读器路径不同，写的路径有自己独特的定义。 虽然读取器路径通过路径匹配可以解析为XDrive上的多个文件，但是写入器路径应映射到仅一个目标文件。
 在外部表的任何INSERT上，目标文件将被创建（如果它已经存在，将被覆盖） 并写入数据。 为了便于为写入创建唯一的文件名，可以使用#UUID＃替换模式注释写路
径。 写时＃UUID＃将被一个生成的UUID替换，这样，每个INSERT语句将创建一个独特的新文件。
\end_layout

\begin_layout Standard
继续我们上面的例子，我们将使用以下外部表将lineitems插入到2016年1月分区：
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE WRITABLE EXTERNAL TABLE 
\end_layout

\begin_layout Plain Layout

   write_lineitem_2016_01 (columnspec) 
\end_layout

\begin_layout Plain Layout

LOCATION 
\end_layout

\begin_layout Plain Layout

   (’xdrive://host:port/dw/lineitem/2016/01/      
\backslash

\end_layout

\begin_layout Plain Layout

                           lineitem_#UUID#.spq') 
\end_layout

\begin_layout Plain Layout

FORMAT ’SPQ’;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
请注意，上面读的XDrive 外部表定义中，读路径使用了通配符。 新写的文件可以匹配，从而数据可以从外部表读出。
\end_layout

\begin_layout Section
dg transfer
\end_layout

\begin_layout Standard
dg transfer 是DeepGreen 数据库之间的高性能，可扩展的数据传输工具。 功能上大体与 gptransfer 类似，但性能要好很多。
 要设置传输，用户应该已经启动源和目标DeepGreen群集。 dg传输需要一个xdrive集群，通常是在目标DeepGreen集群上启动的xdrive集群。
 请参考dg xdrive如何初始化，启动xdrive集群。 Dg传输还需要在源数据库中正确设置dg_utilts。 一旦正确设置，用户可以使用数据库传输。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dg transfer -src.host= -src.port= -src.db= 
\end_layout

\begin_layout Plain Layout

            -dst.host= -dst.port= -dst.db=
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dg transfer 支持如下选项，
\begin_inset listings
inline false
status open

\begin_layout Description

-src.host Source deepgreen cluster connection 
\end_layout

\begin_layout Description

          information host.
\end_layout

\begin_layout Description

-src.port Source deepgreen cluster connection 
\end_layout

\begin_layout Description

          information port.
\end_layout

\begin_layout Description

-src.user Source deepgreen cluster connection 
\end_layout

\begin_layout Description

          user name.
\end_layout

\begin_layout Description

-src.db Source database name.
\end_layout

\begin_layout Description

-dst.host Destination deepgreen cluster host.
\end_layout

\begin_layout Description

-dst.port Destination deepgreen cluster port.
\end_layout

\begin_layout Description

-dst.user Destination deepgreen cluster user name.
\end_layout

\begin_layout Description

-dst.db Destination database name.
\end_layout

\begin_layout Description

-xdrive.hosts XDrive hosts to use for transfer.
\end_layout

\begin_layout Description

-xdrive.port If using xdrive cluster running in 
\end_layout

\begin_layout Description

            destintion deepgreen cluster, user can 
\end_layout

\begin_layout Description

            just specify xdrive port number instead 
\end_layout

\begin_layout Description

            of using xdrive.hosts.
 
\end_layout

\begin_layout Description

-schema The schema to transfer.
 If not specified, 
\end_layout

\begin_layout Description

        all schemas will be transfered.
\end_layout

\begin_layout Description

-table The table to transfer.
 If not specified, 
\end_layout

\begin_layout Description

       all tables in the schema will be transfered.
\end_layout

\begin_layout Description

-tablelist A file that each line contains schema.table 
\end_layout

\begin_layout Description

           to transfer.
\end_layout

\begin_layout Description

-schemaonly Transfer database schema only, do not copy 
\end_layout

\begin_layout Description

            data over.
\end_layout

\begin_layout Description

-ifexists=drop/keep/skip If destination table already 
\end_layout

\begin_layout Description

            exists, transfer should drop and create 
\end_layout

\begin_layout Description

            new table, or, keep and use the table, 
\end_layout

\begin_layout Description

            or, skip transfer data for the table.
\end_layout

\begin_layout Description

-keepowner If keep destination table owner.
\end_layout

\begin_layout Description

-index Rebuild index after transfer.
\end_layout

\begin_layout Description

-analyze Run analyze after transfer.
\end_layout

\begin_layout Description

-verify Verify the database, or schema, or table specified 
\end_layout

\begin_layout Description

        in the command contains same data.
 -verify is 
\end_layout

\begin_layout Description

        a readonly operation.
 It will not transfer data.
\end_layout

\begin_layout Description

-verbose Print more information during transfer.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
